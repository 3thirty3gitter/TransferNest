import { recordNestingRun } from "@/lib/nesting-telemetry";
// @ts-nocheck

import type { NestedLayout } from '@/app/schema';
import type { ManagedImage } from '@/components/nesting-tool';

/**
 * Advanced MaxRects Bin Packer with CORRECT Rotation Support
 * Bug Fix: Always output ORIGINAL dimensions, track rotation separately
 */
class MaxRectsBinPack {
  constructor(width, height, allowRotations = true) {
    this.binWidth = width;
    this.binHeight = height;
    this.allowRotations = allowRotations;
    this.usedRectangles = [];
    this.freeRectangles = [];
    this.freeRectangles.push({
      x: 0,
      y: 0,
      width: this.binWidth,
      height: this.binHeight,
    });
  }

  insert(width, height, method = 'BestShortSideFit') {
    let newNode = {};
    let score1 = { value: Infinity };
    let score2 = { value: Infinity };

    switch (method) {
      case 'BestShortSideFit':
        newNode = this.findPositionForNewNodeBestShortSideFit(width, height, score1, score2);
        break;
      case 'BestLongSideFit':
        newNode = this.findPositionForNewNodeBestLongSideFit(width, height, score2, score1);
        break;
      case 'BestAreaFit':
        newNode = this.findPositionForNewNodeBestAreaFit(width, height, score1, score2);
        break;
      case 'BottomLeft':
        newNode = this.findPositionForNewNodeBottomLeft(width, height, score1, score2);
        break;
      case 'ContactPoint':
        newNode = this.findPositionForNewNodeContactPoint(width, height, score1);
        break;
    }

    if (newNode.height === 0 || newNode.width === 0) {
      return null;
    }

    this.placeRectangle(newNode);
    return newNode;
  }
  
  findPositionForNewNodeBestAreaFit(width, height, bestAreaFit, bestShortSideFit) {
    let bestNode = {x: 0, y: 0, width: 0, height: 0, rotated: false};
    bestAreaFit.value = Infinity;
    bestShortSideFit.value = Infinity;

    for(let i = 0; i < this.freeRectangles.length; ++i) {
        let areaFit = this.freeRectangles[i].width * this.freeRectangles[i].height - width * height;

        if (this.freeRectangles[i].width >= width && this.freeRectangles[i].height >= height) {
            let leftoverHoriz = Math.abs(this.freeRectangles[i].width - width);
            let leftoverVert = Math.abs(this.freeRectangles[i].height - height);
            let shortSideFit = Math.min(leftoverHoriz, leftoverVert);

            if (areaFit < bestAreaFit.value || (areaFit === bestAreaFit.value && shortSideFit < bestShortSideFit.value)) {
                bestNode.x = this.freeRectangles[i].x;
                bestNode.y = this.freeRectangles[i].y;
                bestNode.width = width;
                bestNode.height = height;
                bestNode.rotated = false;
                bestShortSideFit.value = shortSideFit;
                bestAreaFit.value = areaFit;
            }
        }

        if (this.allowRotations && this.freeRectangles[i].width >= height && this.freeRectangles[i].height >= width) {
            let leftoverHoriz = Math.abs(this.freeRectangles[i].width - height);
            let leftoverVert = Math.abs(this.freeRectangles[i].height - width);
            let shortSideFit = Math.min(leftoverHoriz, leftoverVert);

            if (areaFit < bestAreaFit.value || (areaFit === bestAreaFit.value && shortSideFit < bestShortSideFit.value)) {
                bestNode.x = this.freeRectangles[i].x;
                bestNode.y = this.freeRectangles[i].y;
                bestNode.width = height;
                bestNode.height = width;
                bestNode.rotated = true;
                bestShortSideFit.value = shortSideFit;
                bestAreaFit.value = areaFit;
            }
        }
    }
    return bestNode;
  }

  findPositionForNewNodeBestShortSideFit(width, height, bestShortSideFit, bestLongSideFit) {
    let bestNode = { x: 0, y: 0, width: 0, height: 0, rotated: false };
    bestShortSideFit.value = Infinity;
    bestLongSideFit.value = Infinity;

    for (let i = 0; i < this.freeRectangles.length; ++i) {
      if (this.freeRectangles[i].width >= width && this.freeRectangles[i].height >= height) {
        let leftoverHoriz = Math.abs(this.freeRectangles[i].width - width);
        let leftoverVert = Math.abs(this.freeRectangles[i].height - height);
        let shortSideFit = Math.min(leftoverHoriz, leftoverVert);
        let longSideFit = Math.max(leftoverHoriz, leftoverVert);

        if (shortSideFit < bestShortSideFit.value || (shortSideFit === bestShortSideFit.value && longSideFit < bestLongSideFit.value)) {
          bestNode.x = this.freeRectangles[i].x;
          bestNode.y = this.freeRectangles[i].y;
          bestNode.width = width;
          bestNode.height = height;
          bestNode.rotated = false;
          bestShortSideFit.value = shortSideFit;
          bestLongSideFit.value = longSideFit;
        }
      }

      if (this.allowRotations && this.freeRectangles[i].width >= height && this.freeRectangles[i].height >= width) {
        let leftoverHoriz = Math.abs(this.freeRectangles[i].width - height);
        let leftoverVert = Math.abs(this.freeRectangles[i].height - width);
        let shortSideFit = Math.min(leftoverHoriz, leftoverVert);
        let longSideFit = Math.max(leftoverHoriz, leftoverVert);

        if (shortSideFit < bestShortSideFit.value || (shortSideFit === bestShortSideFit.value && longSideFit < bestLongSideFit.value)) {
          bestNode.x = this.freeRectangles[i].x;
          bestNode.y = this.freeRectangles[i].y;
          bestNode.width = height;
          bestNode.height = width;
          bestNode.rotated = true;
          bestShortSideFit.value = shortSideFit;
          bestLongSideFit.value = longSideFit;
        }
      }
    }
    return bestNode;
  }
  
  findPositionForNewNodeBestLongSideFit(width, height, bestShortSideFit, bestLongSideFit) {
    let bestNode = { x: 0, y: 0, width: 0, height: 0, rotated: false };
    bestLongSideFit.value = Infinity;

    for (let i = 0; i < this.freeRectangles.length; i++) {
        if (this.freeRectangles[i].width >= width && this.freeRectangles[i].height >= height) {
            let leftoverHoriz = Math.abs(this.freeRectangles[i].width - width);
            let leftoverVert = Math.abs(this.freeRectangles[i].height - height);
            let shortSideFit = Math.min(leftoverHoriz, leftoverVert);
            let longSideFit = Math.max(leftoverHoriz, leftoverVert);

            if (longSideFit < bestLongSideFit.value || (longSideFit === bestLongSideFit.value && shortSideFit < bestShortSideFit.value)) {
                bestNode.x = this.freeRectangles[i].x;
                bestNode.y = this.freeRectangles[i].y;
                bestNode.width = width;
                bestNode.height = height;
                bestNode.rotated = false;
                bestShortSideFit.value = shortSideFit;
                bestLongSideFit.value = longSideFit;
            }
        }

        if (this.allowRotations && this.freeRectangles[i].width >= height && this.freeRectangles[i].height >= width) {
            let leftoverHoriz = Math.abs(this.freeRectangles[i].width - height);
            let leftoverVert = Math.abs(this.freeRectangles[i].height - width);
            let shortSideFit = Math.min(leftoverHoriz, leftoverVert);
            let longSideFit = Math.max(leftoverHoriz, leftoverVert);

            if (longSideFit < bestLongSideFit.value || (longSideFit === bestLongSideFit.value && shortSideFit < bestShortSideFit.value)) {
                bestNode.x = this.freeRectangles[i].x;
                bestNode.y = this.freeRectangles[i].y;
                bestNode.width = height;
                bestNode.height = width;
                bestNode.rotated = true;
                bestShortSideFit.value = shortSideFit;
                bestLongSideFit.value = longSideFit;
            }
        }
    }
    return bestNode;
  }

  findPositionForNewNodeBottomLeft(width, height, bestY, bestX) {
    let bestNode = { x: 0, y: 0, width: 0, height: 0, rotated: false };
    bestY.value = Infinity;

    for (let i = 0; i < this.freeRectangles.length; i++) {
        if (this.freeRectangles[i].width >= width && this.freeRectangles[i].height >= height) {
            let topSideY = this.freeRectangles[i].y + height;
            if (topSideY < bestY.value || (topSideY === bestY.value && this.freeRectangles[i].x < bestX.value)) {
                bestNode.x = this.freeRectangles[i].x;
                bestNode.y = this.freeRectangles[i].y;
                bestNode.width = width;
                bestNode.height = height;
                bestNode.rotated = false;
                bestY.value = topSideY;
                bestX.value = this.freeRectangles[i].x;
            }
        }

        if (this.allowRotations && this.freeRectangles[i].width >= height && this.freeRectangles[i].height >= width) {
            let topSideY = this.freeRectangles[i].y + width;
            if (topSideY < bestY.value || (topSideY === bestY.value && this.freeRectangles[i].x < bestX.value)) {
                bestNode.x = this.freeRectangles[i].x;
                bestNode.y = this.freeRectangles[i].y;
                bestNode.width = height;
                bestNode.height = width;
                bestNode.rotated = true;
                bestY.value = topSideY;
                bestX.value = this.freeRectangles[i].x;
            }
        }
    }
    return bestNode;
  }

  findPositionForNewNodeContactPoint(width, height, bestContactScore) {
    let bestNode = { x: 0, y: 0, width: 0, height: 0, rotated: false };
    bestContactScore.value = -1;

    for (let i = 0; i < this.freeRectangles.length; i++) {
        if (this.freeRectangles[i].width >= width && this.freeRectangles[i].height >= height) {
            let score = this.contactPointScoreNode(this.freeRectangles[i].x, this.freeRectangles[i].y, width, height);
            if (score > bestContactScore.value) {
                bestNode.x = this.freeRectangles[i].x;
                bestNode.y = this.freeRectangles[i].y;
                bestNode.width = width;
                bestNode.height = height;
                bestNode.rotated = false;
                bestContactScore.value = score;
            }
        }

        if (this.allowRotations && this.freeRectangles[i].width >= height && this.freeRectangles[i].height >= width) {
            let score = this.contactPointScoreNode(this.freeRectangles[i].x, this.freeRectangles[i].y, height, width);
            if (score > bestContactScore.value) {
                bestNode.x = this.freeRectangles[i].x;
                bestNode.y = this.freeRectangles[i].y;
                bestNode.width = height;
                bestNode.height = width;
                bestNode.rotated = true;
                bestContactScore.value = score;
            }
        }
    }
    return bestNode;
  }

  contactPointScoreNode(x, y, width, height) {
    let score = 0;

    if (x === 0 || x + width === this.binWidth)
        score += height;
    if (y === 0 || y + height === this.binHeight)
        score += width;

    for (let i = 0; i < this.usedRectangles.length; i++) {
        if (this.usedRectangles[i].x === x + width || this.usedRectangles[i].x + this.usedRectangles[i].width === x)
            score += this.commonIntervalLength(this.usedRectangles[i].y, this.usedRectangles[i].y + this.usedRectangles[i].height, y, y + height);
        if (this.usedRectangles[i].y === y + height || this.usedRectangles[i].y + this.usedRectangles[i].height === y)
            score += this.commonIntervalLength(this.usedRectangles[i].x, this.usedRectangles[i].x + this.usedRectangles[i].width, x, x + width);
    }
    return score;
  }

  commonIntervalLength(i1start, i1end, i2start, i2end) {
    if (i1end < i2start || i2end < i1start)
        return 0;
    return Math.min(i1end, i2end) - Math.max(i1start, i2start);
  }

  placeRectangle(node) {
    let numRectanglesToProcess = this.freeRectangles.length;
    for (let i = 0; i < numRectanglesToProcess; ++i) {
      if (this.splitFreeNode(this.freeRectangles[i], node)) {
        this.freeRectangles.splice(i, 1);
        --i;
        --numRectanglesToProcess;
      }
    }
    this.pruneFreeList();
    this.usedRectangles.push(node);
  }

  splitFreeNode(freeNode, usedNode) {
    if (
      usedNode.x >= freeNode.x + freeNode.width ||
      usedNode.x + usedNode.width <= freeNode.x ||
      usedNode.y >= freeNode.y + freeNode.height ||
      usedNode.y + usedNode.height <= freeNode.y
    )
      return false;

    if (usedNode.x < freeNode.x + freeNode.width && usedNode.x + usedNode.width > freeNode.x) {
      if (usedNode.y > freeNode.y && usedNode.y < freeNode.y + freeNode.height) {
        let newNode = { ...freeNode };
        newNode.height = usedNode.y - newNode.y;
        this.freeRectangles.push(newNode);
      }
      if (usedNode.y + usedNode.height < freeNode.y + freeNode.height) {
        let newNode = { ...freeNode };
        newNode.y = usedNode.y + usedNode.height;
        newNode.height = freeNode.y + freeNode.height - (usedNode.y + usedNode.height);
        this.freeRectangles.push(newNode);
      }
    }

    if (usedNode.y < freeNode.y + freeNode.height && usedNode.y + usedNode.height > freeNode.y) {
      if (usedNode.x > freeNode.x && usedNode.x < freeNode.x + freeNode.width) {
        let newNode = { ...freeNode };
        newNode.width = usedNode.x - newNode.x;
        this.freeRectangles.push(newNode);
      }
      if (usedNode.x + usedNode.width < freeNode.x + freeNode.width) {
        let newNode = { ...freeNode };
        newNode.x = usedNode.x + usedNode.width;
        newNode.width = freeNode.x + freeNode.width - (usedNode.x + usedNode.width);
        this.freeRectangles.push(newNode);
      }
    }
    return true;
  }

  pruneFreeList() {
    for (let i = 0; i < this.freeRectangles.length; ++i) {
      for (let j = i + 1; j < this.freeRectangles.length; ++j) {
        if (this.isContainedIn(this.freeRectangles[i], this.freeRectangles[j])) {
          this.freeRectangles.splice(i, 1);
          --i;
          break;
        }
        if (this.isContainedIn(this.freeRectangles[j], this.freeRectangles[i])) {
          this.freeRectangles.splice(j, 1);
          --j;
        }
      }
    }
  }

  isContainedIn(a, b) {
    return (
      a.x >= b.x &&
      a.y >= b.y &&
      a.x + a.width <= b.x + b.width &&
      a.y + a.height <= b.y + b.height
    );
  }

  occupancy() {
    let usedSurfaceArea = 0;
    for (let i = 0; i < this.usedRectangles.length; i++) {
        usedSurfaceArea += this.usedRectangles[i].width * this.usedRectangles[i].height;
    }
    let maxY = 0;
    for (let i = 0; i < this.usedRectangles.length; i++) {
        maxY = Math.max(maxY, this.usedRectangles[i].y + this.usedRectangles[i].height);
    }
    if (maxY === 0) return 0;
    return usedSurfaceArea / (this.binWidth * maxY);
  }
}

export const VIRTUAL_SHEET_HEIGHT = 20000;

const SORT_STRATEGIES = {
  AREA_DESC: (a, b) => (b.width * b.height) - (a.width * a.height),
  HEIGHT_DESC: (a, b) => b.height - a.height,
  WIDTH_DESC: (a, b) => b.width - a.width,
  PERIMETER_DESC: (a, b) => ((b.width + b.height) * 2) - ((a.width + a.height) * 2),
  MAX_SIDE_DESC: (a, b) => Math.max(b.width, b.height) - Math.max(a.width, a.height),
};

export function executeNesting(
  images: ManagedImage[],
  sheetWidth: number,
  virtualHeight: number = VIRTUAL_SHEET_HEIGHT,
  method: 'BestShortSideFit' | 'BestLongSideFit' | 'BestAreaFit' | 'BottomLeft' | 'ContactPoint' = 'BestShortSideFit'
) {
  const margin = 0.1;

  const allItems = images.flatMap(img =>
    Array.from({ length: img.copies || 1 }, (_, i) => ({
      ...img,
      id: `${img.id}-copy${i}`,
      originalWidth: img.width,
      originalHeight: img.height,
      widthWithMargin: img.width + margin,
      heightWithMargin: img.height + margin,
    }))
  );

  let bestResult = null;
  let bestEfficiency = 0;

  for (const [strategyName, sortFn] of Object.entries(SORT_STRATEGIES)) {
    const sortedItems = [...allItems].sort(sortFn);
    const result = packItems(sortedItems, sheetWidth, virtualHeight, method, margin);
    
    if (result.placedCount === allItems.length && result.efficiency > bestEfficiency) {
      bestResult = result;
      bestEfficiency = result.efficiency;
      bestResult.sortStrategy = strategyName;
    }
  }

  if (!bestResult) {
    bestResult = packItems(allItems.sort(SORT_STRATEGIES.AREA_DESC), sheetWidth, virtualHeight, method, margin);
    bestResult.sortStrategy = 'AREA_DESC';
  }

  return bestResult;
}

function packItems(items, sheetWidth, virtualHeight, method, margin) {
  const packer = new MaxRectsBinPack(sheetWidth, virtualHeight, true);
  const placedItems: NestedLayout = [];
  const failedItems: Array<{id: string, reason: string}> = [];
  let maxSheetY = 0;

  for (const item of items) {
    const rect = packer.insert(item.widthWithMargin, item.heightWithMargin, method);

    if (rect) {
      // CRITICAL FIX: Always use ORIGINAL dimensions for output
      // The 'rotated' flag tells the frontend to rotate visually
      placedItems.push({
        id: item.id,
        url: item.url,
        x: rect.x + margin / 2,
        y: rect.y + margin / 2,
        width: item.originalWidth,   // ← ALWAYS ORIGINAL
        height: item.originalHeight, // ← ALWAYS ORIGINAL
        rotated: rect.rotated,       // ← Track rotation separately
      });
      maxSheetY = Math.max(maxSheetY, rect.y + rect.height);
    } else {
      failedItems.push({
        id: item.id,
        reason: `Could not fit ${item.originalWidth.toFixed(1)}x${item.originalHeight.toFixed(1)}`
      });
    }
  }

  if (failedItems.length > 0) {
    console.warn(`⚠️ Failed to place ${failedItems.length}/${items.length} items`, failedItems);
  }

  const efficiency = packer.occupancy();

  return {
    placedItems,
    sheetLength: maxSheetY,
    areaUtilizationPct: efficiency,
    failedCount: failedItems.length,
    totalCount: items.length,
    placedCount: placedItems.length,
    efficiency: efficiency,
  };
}

export function calculateOccupancy(placedItems, sheetWidth, sheetLength) {
    if (sheetLength === 0) return 0;
    let usedSurfaceArea = 0;
    for (const item of placedItems) {
        usedSurfaceArea += item.width * item.height;
    }
    const totalSheetArea = sheetWidth * sheetLength;
    return usedSurfaceArea / totalSheetArea;
}
